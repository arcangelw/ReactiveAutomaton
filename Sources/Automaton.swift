//
//  Automaton.swift
//  ReactiveAutomaton
//
//  Created by Yasuhiro Inami on 2016-05-07.
//  Copyright Â© 2016 Yasuhiro Inami. All rights reserved.
//

import ReactiveSwift

/// Deterministic finite state machine that receives "input"
/// and with "current state" transform to "next state" & "output (additional effect)".
public final class Automaton<State, Input>
{
    /// Basic state-transition function type.
    public typealias Mapping = (State, Input) -> State?

    /// Transducer (input & output) mapping with
    /// `SignalProducer<Input, Never>` (additional effect) as output,
    /// which may emit next input values for continuous state-transitions.
    public typealias EffectMapping = (State, Input) -> (State, SignalProducer<Input, Never>)?

    /// `Reply` signal that notifies either `.success` or `.failure` of state-transition on every input.
    public let replies: Signal<Reply<State, Input>, Never>

    /// Current state.
    public let state: Property<State>

    fileprivate let _replyObserver: Signal<Reply<State, Input>, Never>.Observer

    fileprivate var _disposable: Disposable?

    ///
    /// Initializer using `Mapping`.
    ///
    /// - Parameters:
    ///   - state: Initial state.
    ///   - input: `Signal<Input, Never>` that automaton receives.
    ///   - mapping: Simple `Mapping` that designates next state only (no additional effect).
    ///
    public convenience init(state initialState: State, input inputSignal: Signal<Input, Never>, mapping: @escaping Mapping)
    {
        self.init(state: initialState, input: inputSignal, mapping: { _toEffectMapping(mapping($0, $1)) })
    }

    ///
    /// Initializer using `EffectMapping`.
    ///
    /// - Parameters:
    ///   - state: Initial state.
    ///   - input: `Signal<Input, Never>` that automaton receives.
    ///   - mapping: `EffectMapping` that designates next state and also generates additional effect.
    ///   - strategy: `FlattenStrategy` that flattens additional effect generated by `EffectMapping`.
    ///
    public init(state initialState: State, input inputSignal: Signal<Input, Never>, mapping: @escaping EffectMapping, strategy: FlattenStrategy = .merge)
    {
        let stateProperty = MutableProperty(initialState)
        self.state = Property(stateProperty)

        (self.replies, self._replyObserver) = Signal<Reply<State, Input>, Never>.pipe()

        /// Recursive input-producer that sends inputs from `inputSignal`
        /// and also from additional effect generated by `EffectMapping`.
        func recurInputProducer(_ inputProducer: SignalProducer<Input, Never>, strategy: FlattenStrategy) -> SignalProducer<Reply<State, Input>, Never>
        {
            return SignalProducer { observer, disposable in
                inputProducer
                    .withLatest(from: stateProperty.producer)
                    .map { input, fromState in
                        return (input, fromState, mapping(fromState, input))
                    }
                    .startWithSignal { mappingSignal, mappingSignalDisposable in
                        //
                        // NOTE:
                        // `mergedProducer` (below) doesn't emit `.Interrupted` although `mappingSignal` sends it,
                        // so propagate it to returning producer manually.
                        //
                        disposable += mappingSignal.observeInterrupted {
                            observer.sendInterrupted()
                        }

                        //
                        // NOTE:
                        // Split `mappingSignal` into `successSignal` and `failureSignal` (and merge later) so that
                        // inner producers of `flatMap(strategy)` in `successSignal` don't get interrupted by mapping failure.
                        //
                        let successSignal = mappingSignal
                            .filterMap { input, fromState, mapped in
                                return mapped.map { (input, fromState, $0) }
                            }
                            .flatMap(strategy) { input, fromState, mapped -> SignalProducer<Reply<State, Input>, Never> in
                                let (toState, effect) = mapped
                                return recurInputProducer(effect, strategy: strategy)
                                    .prefix(value: .success(input, fromState, toState))
                            }

                        let failureSignal = mappingSignal
                            .filterMap { input, fromState, mapped -> Reply<State, Input>? in
                                return mapped == nil ? .failure(input, fromState) : nil
                            }

                        let mergedProducer = SignalProducer(values: failureSignal, successSignal).flatten(.merge)

                        disposable += mergedProducer.start(observer)
                        disposable += mappingSignalDisposable
                    }
            }
        }

        recurInputProducer(SignalProducer(inputSignal), strategy: strategy)

            .startWithSignal { replySignal, disposable in
                self._disposable = disposable

                stateProperty <~ replySignal.filterMap { $0.toState }

                replySignal.observe(self._replyObserver)
            }
    }

    deinit
    {
        self._replyObserver.sendCompleted()
        self._disposable?.dispose()
    }

}

// MARK: Private

private func _toEffectMapping<State, Input>(_ toState: State?) -> (State, SignalProducer<Input, Never>)?
{
    if let toState = toState {
        return (toState, .empty)
    }
    else {
        return nil
    }
}
